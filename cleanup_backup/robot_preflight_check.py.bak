#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CR3 Robot Pre-flight Verification Script

This script performs basic testing of the CR3 robot connection and movement
capabilities before running the main hand tracking system. It verifies:

1. Network connectivity to robot
2. Robot API communication
3. Robot status and alarm checking
4. Basic movement test (initial ‚Üí packing ‚Üí initial)

Run this script before startup.py to ensure your laptop can communicate with
the robot and that it can accept movement commands without errors.

Usage:
    python robot_preflight_check.py [--robot-ip 192.168.1.6] [--quick]

Options:
    --robot-ip IP    Robot IP address (default: 192.168.1.6)
    --quick          Run quick test (no movement)
"""

import sys
import os
import time
import argparse
import socket
import re
from typing import Optional

# Add robot API path
sys.path.append(os.path.join(os.path.dirname(__file__), 'TCP-IP-CR-Python-V4'))

try:
    from dobot_api import DobotApiDashboard, DobotApiFeedBack
    ROBOT_API_AVAILABLE = True
except ImportError as e:
    print(f"‚ùå Robot API not available: {e}")
    print("Please check TCP-IP-CR-Python-V4 installation.")
    ROBOT_API_AVAILABLE = False


class RobotPreflightChecker:
    """Simple robot verification system"""
    
    def __init__(self, robot_ip: str = "192.168.1.6"):
        self.robot_ip = robot_ip
        self.dashboard_port = 29999
        self.move_port = 30003
        self.feed_port = 30004
        
        # Connection objects
        self.dashboard = None
        
        # Test results
        self.test_results = {}
        self.initial_position = None
        self.packing_position = [250, 0, 300, 0, 0, 0]  # Safe packing position
        
        # Safety parameters
        self.movement_timeout = 10  # seconds
        self.position_tolerance = 5.0  # mm
    
    def log_test(self, test_name: str, passed: bool, message: str = ""):
        """Log test results with formatting"""
        self.test_results[test_name] = passed
        status = "‚úÖ" if passed else "‚ùå"
        print(f"{status} {test_name}: {message}")

    def test_network_connectivity(self) -> bool:
        """Test 1: Basic network connectivity"""
        print("\n" + "="*60)
        print("üåê TEST 1: NETWORK CONNECTIVITY")
        print("="*60)
        
        try:
            # Test robot dashboard port
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5.0)
            result = sock.connect_ex((self.robot_ip, self.dashboard_port))
            sock.close()
            
            if result == 0:
                self.log_test("Network Connectivity", True, f"Robot accessible at {self.robot_ip}:{self.dashboard_port}")
                return True
            else:
                self.log_test("Network Connectivity", False, f"Cannot reach {self.robot_ip}:{self.dashboard_port}")
                print("üí° Check robot IP address and network connection")
                print("üí° Ensure robot is powered on and in TCP/IP mode")
                return False
        except Exception as e:            
            self.log_test("Network Connectivity", False, f"Network error: {e}")
            return False
    
    def test_robot_connection(self) -> bool:
        print("\n" + "="*60)
        print("ü§ñ TEST 2: ROBOT API CONNECTION")
        print("="*60)
        
        if not ROBOT_API_AVAILABLE:
            self.log_test("Robot API Connection", False, "Robot API not available")
            return False
        
        try:
            # Create dashboard connection
            self.dashboard = DobotApiDashboard(self.robot_ip, self.dashboard_port)
            # Test connection with basic command
            print("Connecting to robot dashboard...")
            mode_response = self.dashboard.RobotMode()
            
            if mode_response and len(mode_response) > 0:
                robot_mode = mode_response[0] if isinstance(mode_response, list) else mode_response
                self.log_test("Robot API Connection", True, f"Connected, Robot mode: {robot_mode}")
                return True
            else:
                self.log_test("Robot API Connection", False, "No response from robot")
                return False
                
        except Exception as e:            
            self.log_test("Robot API Connection", False, f"Connection failed: {e}")
            return False
    
    def check_robot_alarms(self, description: str = "Checking for robot alarms") -> bool:
        """
        Common method to check for robot alarms
        Returns True if no alarms, False if alarms detected
        """
        print(f"{description}...")
        alarm_ok = True
        
        try:
            alarm_response = self.dashboard.GetErrorID()
            print(f"Raw alarm response: {alarm_response}")
            # Improved alarm parsing - the response format is complex
            
            if alarm_response:
                alarm_str = str(alarm_response)
                
                # Check for actual error indicators
                # The response contains "null" and empty arrays when no errors
                # Also check for GetErrorID command echo which is part of normal response
                if ("null" in alarm_str or 
                    "[]" in alarm_str or 
                    "GetErrorID();" in alarm_str or
                    alarm_str.strip() in ['0', '[]', 'null']):
                    alarm_ok = True
                    print("‚úÖ No active alarms detected")
                else:
                    # Look for actual numeric error codes (not 0, not in command echo)
                    # Find actual error numbers (non-zero, not part of command formatting)
                    error_numbers = re.findall(r'\b([1-9][0-9]*)\b', alarm_str)
                    # Filter out numbers that are part of the API response formatting
                    actual_errors = [e for e in error_numbers if e not in ['0', '1', '2', '3', '4', '5', '6'] or len(error_numbers) == 1]
                    
                    if actual_errors:
                        alarm_ok = False
                        print(f"‚ùå Active error codes detected: {actual_errors}")
                        print("üí° Clear robot alarms via teach pendant before proceeding")
                    else:
                        alarm_ok = True
                        print("‚úÖ No active alarms detected")
            else:
                alarm_ok = True
                print("‚úÖ No alarm response (assuming OK)")
                
        except Exception as e:
            print(f"Could not check alarms: {e}")
            alarm_ok = True  # Assume OK if we can't check
            
        return alarm_ok
    
    def test_robot_status(self) -> bool:
        """Test 3: Robot status and alarms with robot enablement"""
        print("\n" + "="*60)
        print("‚öïÔ∏è TEST 3: ROBOT STATUS & ENABLEMENT")
        print("="*60)
        
        if not self.dashboard:
            self.log_test("Robot Status", False, "No robot connection")
            return False
        
        try:
            # Step 1: Clear any existing errors first
            print("Clearing any existing robot errors...")
            try:
                clear_result = self.dashboard.ClearError()
                print(f"Clear errors result: {clear_result}")
                time.sleep(1)
            except Exception as e:
                print(f"Note: Could not clear errors: {e}")
            
            # Step 2: Check for alarms BEFORE robot enablement
            pre_alarm_ok = self.check_robot_alarms("Checking for robot alarms BEFORE enablement")
            
            # Step 3: Check and enable robot if needed
            mode_response = self.dashboard.RobotMode()            
            
            if mode_response:
                # Parse robot mode more carefully - extract numeric mode from response
                robot_mode_str = str(mode_response)
                print(f"Raw robot mode response: {robot_mode_str}")
                # Extract just the numeric mode from complex response
                mode_match = re.search(r'\b([0-9]+)\b', robot_mode_str)
                if mode_match:
                    actual_mode = int(mode_match.group(1))
                else:
                    actual_mode = 0
                
                print(f"Parsed Robot Mode: {actual_mode}")
                # Enable robot if it's not in running mode
                if actual_mode != 5:  # Not in running mode
                    print("Robot not enabled. Attempting to enable...")
                    try:
                        enable_result = self.dashboard.EnableRobot()
                        print(f"Enable robot result: {enable_result}")
                        
                        # Wait for robot to enable with timeout and progress indication
                        print("Waiting for robot to enable", end="")
                        max_wait_time = 10  # seconds
                        check_interval = 0.5  # seconds
                        elapsed_time = 0
                        mode_ok = False
                        
                        while elapsed_time < max_wait_time:
                            time.sleep(check_interval)
                            elapsed_time += check_interval
                            print(".", end="", flush=True)
                            
                            # Check if robot is now enabled
                            try:
                                new_mode_response = self.dashboard.RobotMode()
                                if new_mode_response:
                                    new_mode_str = str(new_mode_response)
                                    new_mode_match = re.search(r'\b([0-9]+)\b', new_mode_str)
                                    if new_mode_match:
                                        new_actual_mode = int(new_mode_match.group(1))
                                        if new_actual_mode == 5:  # Successfully enabled
                                            mode_ok = True
                                            print(f"\n‚úÖ Robot enabled successfully (mode {new_actual_mode}) after {elapsed_time:.1f}s")
                                            break
                            except Exception:
                                continue  # Keep trying
                        
                        if not mode_ok:
                            print(f"\n‚è∞ Timeout waiting for robot to enable after {max_wait_time}s")
                            # One final check
                            try:
                                final_mode_response = self.dashboard.RobotMode()
                                if final_mode_response:
                                    final_mode_str = str(final_mode_response)
                                    final_mode_match = re.search(r'\b([0-9]+)\b', final_mode_str)
                                    if final_mode_match:
                                        final_actual_mode = int(final_mode_match.group(1))
                                        print(f"Final Robot Mode: {final_actual_mode}")
                                        mode_ok = final_actual_mode == 5
                            except Exception as e:
                                print(f"Could not get final mode: {e}")
                            
                            if not mode_ok:
                                print("üí° Robot may need to be manually enabled via teach pendant")
                                print("üí° Check robot status on teach pendant display")
                        
                    except Exception as e:
                        print(f"Failed to enable robot: {e}")
                        print("üí° Try manually enabling robot via teach pendant")
                        mode_ok = False
                else:
                    mode_ok = True
                    print("‚úÖ Robot is already in running mode")
            else:
                mode_ok = False
                print("Could not get robot mode")
            
            # Step 4: Check for alarms AFTER robot enablement
            post_alarm_ok = self.check_robot_alarms("Checking for robot alarms AFTER enablement")
            
            # Step 5: Get current position for reference
            try:
                print("Getting current robot position...")
                pos_response = self.dashboard.GetPose()
                if pos_response:
                    # Parse position data from complex response
                    position_str = str(pos_response)
                    print(f"Raw position response: {position_str}")
                    # Extract numeric values from the response
                    numbers = re.findall(r'-?\d+\.?\d*', position_str)
                    if len(numbers) >= 6:
                        self.initial_position = [float(n) for n in numbers[:6]]
                        print(f"Current position: X={self.initial_position[0]:.1f}, Y={self.initial_position[1]:.1f}, Z={self.initial_position[2]:.1f}")
                    else:
                        print(f"Could not parse position from: {numbers}")
            except Exception as e:
                print(f"Could not get position: {e}")
            
            # Final status assessment
            alarm_ok = pre_alarm_ok and post_alarm_ok
            success = mode_ok and alarm_ok
            
            if success:
                status_msg = "Robot enabled and ready"
            else:
                issues = []
                if not mode_ok:
                    issues.append("mode not ready")
                if not alarm_ok:
                    issues.append("active alarms")
                status_msg = f"Robot not ready: {', '.join(issues)}"
            
            self.log_test("Robot Status", success, status_msg)
            return success
            
        except Exception as e:
            self.log_test("Robot Status", False, f"Status check failed: {e}")
            return False
    
    def test_movement(self) -> bool:
        """Test 4: Basic movement capability"""
        print("\n" + "="*60)
        print("üèÉ TEST 4: MOVEMENT TEST")
        print("="*60)
        
        if not self.dashboard:
            self.log_test("Movement Test", False, "No robot connection")
            return False
        
        try:
            # Get initial position
            if not self.initial_position:
                pos_response = self.dashboard.GetPose()
                if pos_response:
                    position_data = pos_response if isinstance(pos_response, list) else [pos_response]
                    self.initial_position = position_data[:6] if len(position_data) >= 6 else None
                
                if not self.initial_position:
                    self.log_test("Movement Test", False, "Cannot get initial position")
                    return False
            
            print(f"Initial position: {self.initial_position}")
            # Move to packing position
            print("Moving to packing position...")
            move_cmd = f"MovJ({','.join(map(str, self.packing_position))})"
            print(f"Sending command: {move_cmd}")
            move_response = self.dashboard.mov(move_cmd)
            print(f"Move command response: {move_response}")
            
            # Wait for movement to complete with better monitoring
            print("Waiting for movement to complete", end="")
            max_move_wait = 8  # seconds
            move_check_interval = 0.5
            move_elapsed = 0
            
            while move_elapsed < max_move_wait:
                time.sleep(move_check_interval)
                move_elapsed += move_check_interval
                print(".", end="", flush=True)
            
            print(f"\nMovement wait completed after {move_elapsed:.1f}s")
            
            # Check if we reached the target
            current_pos_response = self.dashboard.GetPose()
            if current_pos_response:
                # Parse current position properly
                position_str = str(current_pos_response)
                numbers = re.findall(r'-?\d+\.?\d*', position_str)
                if len(numbers) >= 6:
                    current_pos = [float(n) for n in numbers[:6]]
                    print(f"Current position after move: X={current_pos[0]:.1f}, Y={current_pos[1]:.1f}, Z={current_pos[2]:.1f}")
                    
                    # Check if we're close to target
                    distance = sum((current_pos[i] - self.packing_position[i])**2 for i in range(3))**0.5
                    print(f"Distance from target: {distance:.1f}mm")
                else:
                    print(f"Could not parse current position: {numbers}")
            
            # Return to initial position
            print("Returning to initial position...")
            return_cmd = f"MovJ({','.join(map(str, self.initial_position))})"
            print(f"Sending return command: {return_cmd}")
            return_response = self.dashboard.mov(return_cmd)
            print(f"Return command response: {return_response}")
            
            # Wait for return movement
            print("Waiting for return movement", end="")
            return_elapsed = 0
            while return_elapsed < max_move_wait:
                time.sleep(move_check_interval)
                return_elapsed += move_check_interval
                print(".", end="", flush=True)
            
            print(f"\nReturn movement completed after {return_elapsed:.1f}s")
            
            # Verify we're back at initial position
            final_pos_response = self.dashboard.GetPose()
            if final_pos_response:
                position_str = str(final_pos_response)
                numbers = re.findall(r'-?\d+\.?\d*', position_str)
                if len(numbers) >= 6:
                    final_pos = [float(n) for n in numbers[:6]]
                    print(f"Final position: X={final_pos[0]:.1f}, Y={final_pos[1]:.1f}, Z={final_pos[2]:.1f}")
                    
                    # Check distance from initial
                    return_distance = sum((final_pos[i] - self.initial_position[i])**2 for i in range(3))**0.5
                    print(f"Distance from initial position: {return_distance:.1f}mm")
            
            self.log_test("Movement Test", True, "Movement test completed")
            return True
            
        except Exception as e:
            self.log_test("Movement Test", False, f"Movement failed: {e}")
            return False
    
    def cleanup(self):
        """Clean up connections safely"""
        if self.dashboard:
            try:
                # Use the dashboard's built-in disconnect method if available
                if hasattr(self.dashboard, 'disconnect'):
                    self.dashboard.disconnect()
                elif hasattr(self.dashboard, 'close'):
                    self.dashboard.close()
            except Exception as e:
                # Ignore socket closing errors during cleanup
                if "10038" not in str(e) and "not a socket" not in str(e).lower():
                    print(f"Note: Error during cleanup: {e}")
            finally:
                self.dashboard = None
    
    def run_preflight_check(self, quick_test: bool = False) -> bool:
        """Run complete preflight check"""
        print("üöÄ ROBOT PRE-FLIGHT CHECK STARTING")
        print(f"Robot IP: {self.robot_ip}")
        print(f"Quick test: {'Yes' if quick_test else 'No'}")
        print("="*60)
        
        try:
            # Test 1: Network connectivity
            if not self.test_network_connectivity():
                return False
            
            # Test 2: Robot connection
            if not self.test_robot_connection():
                return False
            
            # Test 3: Robot status
            if not self.test_robot_status():
                return False
            
            # Test 4: Movement (skip if quick test)
            if not quick_test:
                if not self.test_movement():
                    return False
            else:
                print("\n‚ö° Skipping movement test (quick mode)")
            
            # Summary
            print("\n" + "="*60)
            print("üìã PRE-FLIGHT CHECK SUMMARY")
            print("="*60)
            
            passed_tests = sum(1 for result in self.test_results.values() if result)
            total_tests = len(self.test_results)
            
            for test_name, passed in self.test_results.items():
                status = "‚úÖ" if passed else "‚ùå"
                print(f"{status} {test_name}")
            
            print(f"\nTests passed: {passed_tests}/{total_tests}")
            
            if passed_tests == total_tests:
                print("\nüéâ ALL TESTS PASSED - Robot ready for operation!")
                return True
            else:
                print(f"\n‚ùå {total_tests - passed_tests} test(s) failed - Check issues above")
                return False
                
        except KeyboardInterrupt:
            print("\n\n‚èπÔ∏è Pre-flight check cancelled by user")
            return False
        except Exception as e:
            print(f"\n‚ùå Pre-flight check error: {e}")
            return False
        finally:
            self.cleanup()


def main():
    """Main function"""
    parser = argparse.ArgumentParser(description="CR3 Robot Pre-flight Check")
    parser.add_argument("--robot-ip", default="192.168.1.6", 
                       help="Robot IP address (default: 192.168.1.6)")
    parser.add_argument("--quick", action="store_true", 
                       help="Run quick test without movement")
    
    args = parser.parse_args()
    
    # Create checker and run tests
    checker = RobotPreflightChecker(args.robot_ip)
    success = checker.run_preflight_check(quick_test=args.quick)
    
    return success


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)
